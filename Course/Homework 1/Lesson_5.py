# Վարժություն 1.13
# Իրականացրեք fast_pow-ն իտերատիվ տարբերակով։


def fast_pow(x, y):
    temp = 0
    if y == 0:
        return 1
    temp = fast_pow(x, y / 2)
    if y % 2 == 0:
        return temp * temp
    else:
        return x * temp * temp


print(fast_pow(2, 4))

"""
Վարժություն 1.14
Աստիճան բարձրացնելու ալգորիթմը հիմնված է հաջորդաբար բազմապատկում կատարելու քայլերի վրա։ Նույնկերպ կարելի է 
իրականացնել բազմապատկումը հաջորդաբար գումարում կատարելու քայլերով։ Ենթադրենք, որ մեր լեզվում չկա բազմապատկում 
կատարելու օպերատոր, և այն պետք է իրականացնել։ Հաջորդ ֆունկցիան իրականացնում է բազմապատկումը, այնպես, ինչպես pow-ն.

>>> def mul(a, b):
	if b == 0:
		return 0
	else:
		return a + mul(a, b - 1)

Այս ալգորիթմը, ինչպես pow-ն, O(n) բարդության է և ժամանակի տեսանկյունից, և հիշողության։ 
Ենթադրենք, որ մեր լեզվում կա double և halve ֆունկցիաները, որոնցից առաջինը ամբողջ թիվը բազմապատկում է 2-ով, 
իսկ մյուսը զույգ թիվը բաժանում է 2-ի։ Օգտագործելով այդ ֆունկցիաները, fast_pow-ի օրինակով իրականացրեք fast_mul 
ֆունկցիան, որը O(log(n)) բարդության է։ 

"""


def fast_mul(a, b):
    if b == 0:
        return 0
    if a % 2 == 0:
        return a/2*(b*2)
    else:
        return (a*(b*2))/2


print(fast_mul(2, 4))
